\documentclass[a4paper,twoside]{memoir}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}
\usepackage{csquotes}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage[bitstream-charter]{mathdesign}
\usepackage[final,babel]{microtype}
\usepackage[hidelinks,pdfpagelayout=TwoPageRight]{hyperref}
\usepackage{xcolor}
\usepackage{menukeys}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{siunitx}
\usepackage{booktabs}

\newcommand{\FrameTitle}[2]{%
  \fboxrule=\FrameRule \fboxsep=\FrameSep
  \fbox{\vbox{\nobreak \vskip -0.7\FrameSep
    \rlap{\centerline{\strut#1}}\nobreak\nointerlineskip% centered
    \vskip 0.7\FrameSep
    \hbox{#2}}}}
\newenvironment{framewithtitle}[2][\FrameFirst@Lab\ (cont.)]{%
  \def\FrameFirst@Lab{\textbf{#2}}%
  \def\FrameCont@Lab{\textbf{#1}}%
  \def\FrameCommand##1{%
    \FrameTitle{\FrameFirst@Lab}{##1}}%
  \def\FirstFrameCommand##1{%
    \FrameTitle{\FrameFirst@Lab}{##1}}%
  \def\MidFrameCommand##1{%
    \FrameTitle{\FrameCont@Lab}{##1}}%
  \def\LastFrameCommand##1{%
    \FrameTitle{\FrameCont@Lab}{##1}}%
\MakeFramed{\advance\hsize-\width \FrameRestore}}%
{\endMakeFramed}

\newcounter{exercisectr}
\newenvironment{exercise}
{\stepcounter{exercisectr}\begin{framewithtitle}{Practical \arabic{exercisectr}}}
{\end{framewithtitle}}

\newenvironment{py}{\begin{minted}{python}}{\end{minted}}

\newcommand{\shellcmd}{\texttt}
\newcommand{\shellvar}[1]{$\langle \text{#1}\rangle$}
\newcommand{\additional}{\medskip\noindent{\textit{Additional exercises}}}
\newcommand{\TODO}[1]{\textcolor{purple}{TODO: \emph{#1}}}
\newcommand{\home}{\raise.17ex\hbox{$\scriptstyle\mathtt{\sim}$}}

\setlist[itemize]{leftmargin=*,label={--}}

\begin{document}
\tableofcontents*

\chapter{The Linux command line}
\label{chap:linux}

\section{Linux commands}

\begin{itemize}
\item Linux offers a command line which allows you to manipulate files, process data, and perform almost any other operation
\item Some commands take options that modify their behaviour.  Options usually start with one hyphen (\shellcmd{-}) or two hyphens (\shellcmd{-{}-}), and appear after the command name.  Options are separated by spaces.
\item Some commands take one or more arguments which often specify the location of a file or directory.  Arguments come after the command and any options, and are also separated by spaces.
\item A typical command with options and arguments might look like this:
\begin{minted}{bash}
$ sort --numeric-sort -r dataSet2013.txt dataSet2014.txt
\end{minted}
\item Most commands come with manuals, called `man pages'; if you know the name of the command, \shellcmd{man \shellvar{mycommand}} displays its man page.  Type \keys{q} to return to the command line.
\item Most commands display their results on the command line.  If instead you want to save the output to a file, you can use output redirection (\shellcmd{>}).  For example
\begin{minted}{bash}
$ sort --numeric-sort dataSet2013.txt > sorted2013.txt
\end{minted}
\item Use \keys{ctrl+c} to abort a command that is currently running
\item Use \keys{ctrl+d} on a blank line when you have finished entering all the input to a command
\end{itemize}

\section{The file system}
\begin{itemize}
\item Linux has a single file system that comprises a tree of directories that contain files
\item The slash symbol (\shellcmd{/}) identifies the root of the tree
\item A pathname identifies a file or directory, which is the path that is taken through the directory tree to reach it
\item The slash symbol is also used to separate the names of files and directories in a pathname
\item An absolute path specifies a location starting from the root of the tree.  Hence, absolute paths always begin with a slash (\shellcmd{/}).
\item The command line remembers your current location in the directory tree, and you can discover its path with the \shellcmd{pwd} command (short for `Print Working Directory')
\item If a path does not start with a \shellcmd{/} then it gives a location that is relative to the current location.  Hence, it is called a `relative path'.
\item Files that belong to the user are stored in a location called the `home' directory which has the path \shellcmd{/home/\shellvar{username}}.  This is analagous to `My Documents' on Microsoft Windows.
\item To save typing the full path, the home directory has a special name, \home\ (the tilde character).
\end{itemize}

\subsection{Directory manipulation}
\begin{itemize}
\item The \shellcmd{ls} command lists the contents of the current directory
\item The \shellcmd{cd} command, short for `Change Directory', changes the current directory to a new location
\item \shellcmd{cd /home/alice/photos/} moves to the \shellcmd{photos} subdirectory in alice's home directory
\item If our current directory is \shellcmd{/home/alice/photos/}, the command \shellcmd{cd 2009/kenya} changes our current directory to \shellcmd{/home/alice/photos/2009/kenya/}
\item To move up a level in the directory tree, we can use the special directory named with two periods (\shellcmd{..})
\item \shellcmd{cd ..} moves up one level to \shellcmd{/home/alice/photos/2009/}
\item And then \shellcmd{cd ../../} moves up another two levels back to alice's home directory, \shellcmd{/home/alice/}
\item Many other commands also accept a pathname.  For example, \shellcmd{ls \home/photos} lists the contents of alice's photos directory (notice that we have used the special \home\ symbol).
\item \shellcmd{mkdir -p \shellvar{pathname}} creates a new directory (and will create any directories that don't already exist in the directory tree)
\end{itemize}

\subsection{File manipulation}
\begin{itemize}
\item Copy a file with the command \shellcmd{cp \shellvar{source} \shellvar{destination}}
\item Copy a directory and all of its contents with \shellcmd{cp -r \shellvar{source} \shellvar{destination}} (where the option \shellcmd{-r} specifies recursive copying)
\item To rename a file or directory, use \shellcmd{mv \shellvar{source} \shellvar{destination}}
\item The same command can be used to move a file or directory to another location in the tree.  For example, \shellcmd{mv photos/2009/kenya photos/2010/} moves the \shellcmd{kenya} directory into the \shellcmd{2010} directory.
\item To delete a file, use \shellcmd{rm \shellvar{file}}
\item To delete a directory and all its contents, first decide if you really want to do this.  There is no Recycle Bin to rescue you.  If you really must, use \shellcmd{rm -r -I \shellvar{directory}}.
\end{itemize}

\begin{exercise}
\TODO{move around the FS, create some files and directories etc}

Try sorting a list of numbers.  The \shellcmd{sort} command takes its input from the command line and expects each list item on a new line.  Try entering the following
\begin{minted}{bash}
$ sort --numeric-sort
11.4
11.2
-2
4
\end{minted}
Type \keys{\ctrl+d} on an empty line when you have finished entering the list.  The result should be printed to the command line.

If you make a mistake entering the data, you can abort the \shellcmd{sort} command by typing \keys{\ctrl+c}.  Notice that no sorting is performed and nothing is printed to the command line.

\additional

In the previous exercise we used the \shellcmd{-{}-numeric-sort} option to sort items numerically.  The \shellcmd{sort} command has many other options that control the way data is sorted.

Try sorting words in reverse alphabetical order, ignoring upper and lower cases.  To find the appropriate options, take a look at the manual page with \shellcmd{man sort}, and type \keys{q} to get back to the command line prompt.

The output of one command can be used as the input to another using a pipe (\shellcmd{|}).  To remove duplicate items in a list, we can sort them, then remove adjacent lines that are the same.  Try the following command
\begin{minted}{bash}
$ sort | uniq
bob
alice
charlie
bob
charlie
\end{minted}
using \keys{ctrl+d} when you have finished entering the list.
\end{exercise}

\chapter{The Python programming language}

\section{Installing Python}

\begin{minted}{bash}
$ sudo apt-get install ipython3 python3-tk
\end{minted}

\TODO{IPython.  quit with ctrl-d}

\section{Numeric data}
\begin{itemize}
\item There are many different types of data in Python including numeric, textual, and boolean (true or false) data types
\item There are three numeric types built into Python
	\begin{description}
	\item[Integer values ($\mathbb{Z}$)]{Examples of integer values are \shellcmd{5} and \shellcmd{-8}.  Unlike some other programming languages, integers in Python have no minimum or maximum value.}
	\item[Real values ($\mathbb{R}$)]{In Python these are called `floating point' numbers, or just `floats'.  Examples of floats are \shellcmd{5.9}, \shellcmd{13.0} and \shellcmd{-2.39e-12} (where \shellcmd{e} means `exponent', so $\text{\shellcmd{-2.39e-12}} = \num{-2.39e-12}$).  Because floats have limited precision, they can only approximate real numbers, and rounding errors often appear when we do arithmetic with floating point values.  We will point out some of the pitfalls in \TODO{xref}.}
	\item[Complex values ($\mathbb{C}$)]{Not covered in this course, but details can be found at \url{https://docs.python.org/3/library/stdtypes.html#typesnumeric}}
	\end{description}
\item Python provides a variety of numeric operators including addition (\shellcmd{+}), subtraction (\shellcmd{-}), multiplication (\shellcmd{*}), division (\shellcmd{/}) and exponentiation (\shellcmd{**})
\item Values can be combined with operators to form expressions.  Python can evaluate expressions and print the result to the command line.  For example, \shellcmd{3 + 6 * -2} prints \shellcmd{-9}, and \shellcmd{5.3 ** 2.5} prints \shellcmd{64.66803638583747}.
\item Python uses the conventional order of operations such that multiplication has a higher precedence than addition, for example.  To make the expression clearer, or to force a different order of evaluation, you can use parentheses.  For example, \shellcmd{(3 + 6) * -2} prints \shellcmd{-18}.  For full details of operator precedence, see \url{https://docs.python.org/3/reference/expressions.html#evaluation-order}.
\end{itemize}

\TODO{casting to int, float}

\begin{exercise}
\begin{enumerate}
\item Try evaluating \shellcmd{12345678901234567890 + 1234567890123456789}.  Now try evaluating \shellcmd{12345678901234567890.0 + 12345678901234567890.0}.  Can you explain why the answers differ?  What is the significance of the decimal place?

\item Try evaluating $3 \div 10$.  Do you get the expected answer?  Now try evaluating $1 \div 10 \times 3$.  Can you explain why the answer is different?

\item Try evaluating \shellcmd{10 + 1e17}.  Why is the answer incorrect?  Can you write a different expression that gives the correct result? % 10 + (10 ** 17)
\end{enumerate}
\end{exercise}

\section{Boolean logic}
\begin{itemize}
\item Another of Python's data types is the boolean type.  Its two values are \shellcmd{True} and \shellcmd{False}.
\item We can evaluate boolean expressions using the boolean operators \shellcmd{and}, \shellcmd{or} and \shellcmd{not}.  For example, \shellcmd{not True} evaluates to \shellcmd{False}.  \shellcmd{True or False} evaluates to \shellcmd{True}.
\item Numeric expressions can be compared for equality or inequality using one of the following operators

\begin{tabular}{ c @{\hspace{2em}} c}
	\toprule
	Mathematical expression & Python expression \\ \midrule
	$3 = 4$			& \shellcmd{3 == 4} \\
	$3 < 4$			& \shellcmd{3 < 4} \\
	$3 \leq 4$		& \shellcmd{3 <= 4} \\
	$3 > 4$			& \shellcmd{3 > 4} \\
	$3 \geq 4$		& \shellcmd{3 >= 4} \\
	$3 \neq 4$		& \shellcmd{3 != 4} \\
	\bottomrule
\end{tabular}

All of these expressions will evaluate to a boolean value of either \shellcmd{True} or \shellcmd{False}.

\item We can construct more elaborate expressions.  For example, $3 < 4 \leq 5$ could be written in Python as \shellcmd{3 < 4 and 4 <= 5} or, more consisely, \shellcmd{3 < 4 <= 5}.

\item Because floats are only approximations, it is dangerous to test that they are equal (\shellcmd{==}) or not equal (\shellcmd{!=}).  When working with floating point numbers, you should almost always compare them for inequality (\shellcmd{<}, \shellcmd{<=}, \shellcmd{>}, \shellcmd{>=}).  
\end{itemize}

\section{Mathematical functions}
\begin{itemize}
\item The features we have covered so far are all built into the Python language itself.  Additional functions are provided by Python modules.  The standard Python implementation includes modules for common tasks including mathematical calculations, and reading and writing files.  Additional modules can be installed for more specialised tasks such as matrix solving and graph plotting.
\item The \shellcmd{math} module provides a variety of common mathematical functions.  To gain access to these functions, you must `import' them from the module using the Python command
\begin{minted}{python}
from math import *
\end{minted}
\item The \shellcmd{math} module is documented at \url{https://docs.python.org/3/library/math.html}.  Some of the most common functions are summarised below

\begin{tabular}{ c @{\hspace{2em}} c}
	\toprule
	Mathematical function	& Python function \\ \midrule
	$\lfloor 3.3 \rfloor$	& \shellcmd{floor(3.3)} \\
	$\lceil 3.3 \rceil$	& \shellcmd{ceil(3.3)} \\
	$e^{3.3}$		& \shellcmd{exp(3.3)} \\
	$\ln(3.3)$		& \shellcmd{log(3.3)} \\
	$\log(3.3)$		& \shellcmd{log10(3.3)} \\
	$\sqrt{3.3}$		& \shellcmd{sqrt(3.3)} \\
	\bottomrule
\end{tabular}

\item The \shellcmd{math} module also includes trigonometric and hyperbolic functions, and also defines the constants $e$ and $\pi$.  For example, we could use them in expressions such as \shellcmd{e ** (-1/3)} or \shellcmd{sin(pi/2)}.
\end{itemize}

\section{Variables}
\begin{itemize}
	\item So far, our expressions have only contained fixed values (known as `literals' in Python)
	\item We can also store variable data.  A variable should be given a name that describes its purpose, such as \shellcmd{bank\_balance}, \shellcmd{user\_name} or \shellcmd{overdrawn}.  \textit{Can you suggest suitable data types for each of these variables?}
	\item Before we can use variables in an expression, we must assign a value.  Here are some examples of assignment statements:
\begin{minted}{python}
	bank_balance = -193
	user_name = "Joe Bloggs"
\end{minted}
	\item A variable's value can also be assigned by evaluating an expression.  For example, we can set the \shellcmd{overdrawn} variable like this:
\begin{minted}{python}
	overdrawn = bank_balance < 0
\end{minted}
	\item You can assign values to multiple variables.  If we wanted to define a point with coordinates $x, y, z$ we could write
\begin{minted}{python}
	(x, y, z) = 13.4, -2.8, 4.0
\end{minted}
	\item A variable can be given a new value using another assignment statement.  Although Python does not enforce it, it is good practice to assign values of the same data type.
	\item We can increment the value of a numeric variable like this
\begin{minted}{python}
	x += 5
\end{minted}
Which is equivalent to writing
\begin{minted}{python}
	x = x + 5
\end{minted}
Similarly, we can decrement, multiply, divide or exponentiate by placing the operator before the equals sign:
\begin{minted}{python}
	x -= 5
	x *= 3
	x /= 4.2
	x **= -1/2
\end{minted}
\end{itemize}

\section{Textual data}
\label{sec:textual}
\begin{itemize}
\item Python has a data type for textual data.  This type is called a `string' because it comprises a string of characters.
\item A string is enclosed in single or double quotes.  Examples of string values are \shellcmd{'hello world'} and \shellcmd{"The quick brown fox"}.
\item You can include placeholders in a string and use the \shellcmd{format} function to replace them with actual values.  For example
\begin{minted}{python}
"The area of a circle with radius {r} is {area}" \
  .format(r=3, area=pi*3**2)
\end{minted}

Which will print
\begin{verbatim}
The area of a circle with radius 3 is 28.274333882308138
\end{verbatim}
Notice that, because the line was quite long, we have used a backslash so that we can continue the code on a second line.

\item If we want to control how values are formatted when they are printed as text, we can use a `format specifier'.  For example, if we want to display the area with 4 significant digits, we can use the format specifier \shellcmd{.4g} and write
\begin{minted}{python}
"The area of a circle with radius {r} is {area:.4g}" \
  .format(r=3, area=pi*3**2)
\end{minted}

Which will print
\begin{verbatim}The area of a circle with radius 3 is 28.27\end{verbatim}

\item There are many more ways to format data, for more information see \url{https://docs.python.org/3/library/string.html#formatspec}.

\item If you have a particularly long string, there are a couple of ways of writing them whilst keeping your code looking tidy
\begin{enumerate}
\item Use a multi-line string.  This is useful when you want to preserve line breaks in the text.  Multi-line strings are enclosed in three double quotes, for example
\begin{minted}{python}
"""An old silent pond...
A frog jumps into the pond,
splash! Silence again."""
\end{minted}
\item Alternatively, use can use the string concatenation operator (\shellcmd{+}).  This lets you split a long string onto several lines of source code:
\begin{minted}{python}
"An old silent pond... " + \
"A frog jumps into the pond, " + \
"splash! Silence again."
\end{minted}
This string will be printed on a single, long line.
\end{enumerate}

\end{itemize}

\begin{exercise}
\TODO{show how == and != are dangerous with fp}

Write some Python code that takes the mean of two real numbers.  The ceiling of the result should be displayed with two significant digits.  \TODO{provide some expected inputs and outputs}
\end{exercise}

\section{Python source files}
\begin{itemize}
\item So far, we have only evaluated Python expressions using the interactive IPython \TODO{console}.  However, complete programs are stored in files.  These are called `source files' since they contain the program's `source code'.  Python source file names have the suffix \shellcmd{.py}.
\item In linux, we must do two things to allow us to execute a Python source file:
\begin{enumerate}
	\item At the top of the file, add the line
\begin{minted}{bash}
#!/usr/bin/env python3
\end{minted}
	\item At the command line, we must issue the command \shellcmd{chmod +x \shellvar{source.py}} (\shellcmd{chmod} is short for `change mode', and \shellcmd{+x} means `enable execution')
\end{enumerate}
\item When we used the interactive console to evaluate expressions, the results were printed immediately.  However, we must use the \shellcmd{print()} function in a Python program.  For example, to print the area of a circle, as we did in section~\ref{sec:textual}, we could write the following program
\begin{minted}{python}
#!/usr/bin/env python3
from math import *

print("The area of a circle with radius {r} is {area:.4g}" \
	.format(r=3, area=pi*3**2))
\end{minted}
\item If we save this source file to \shellcmd{\home/mpecdt-python/circle-area.py}, and \shellcmd{cd} to the \shellcmd{\home/mpecdt-python/} directory, we can execute our program on the command line like this
\begin{minted}{bash}
	$ ./circle-area.py
\end{minted}
\item Sometimes it is useful for a Python program to accept command line arguments (as described in chapter~\ref{chap:linux}).  For example, we might want to specify the radius on the command line.  The \shellcmd{sys} module lets us achieve this
\begin{minted}{python}
#!/usr/bin/env python3
from math import *
import sys

radius = float(sys.argv[1])

print("The area of a circle with radius {r} is {area:.4g}" \
	.format(r=radius, area=pi*radius**2))
\end{minted}
Now we can execute the program like this:
\begin{minted}{bash}
$ ./circle-area.py 4.5
The area of a circle with radius 4.5 is 63.62
\end{minted}
The \shellcmd{argv} variable is an array of strings.  We will describe arrays later in section~\TODO{xref}.

\item If you have a lot of input data, it isn't convenient to provide it as a command line argument.  Instead, we can store the data in a file and use linux to send this data to our Python program.

We will modify our \shellcmd{circle-area.py} program to demonstrate this:
\begin{minted}{python}
#!/usr/bin/env python3
from math import *
import sys

radius = float(sys.stdin.readline())

print("The area of a circle with radius {r} is {area:.4g}" \
	.format(r=radius, area=pi*radius**2))
\end{minted}
Now, to execute the program, we must create a text file containing the radius value, let's call it \shellcmd{radius.txt}.  Then we use the input redirection operator (\shellcmd{<}) like so
\begin{minted}{bash}
$ ./circle-area.py < radius.txt
The area of a circle with radius 4.5 is 63.62
\end{minted}
\item If we wanted the result to be saved to a file, we could use output redirection operator (\shellcmd{>}) as well:
\begin{minted}{bash}
$ ./circle-area.py < radius.txt > area.txt
\end{minted}
\end{itemize}

\begin{exercise}
Using the code you wrote in Practical \TODO{xref}, create a complete Python program that has the same behaviour as before.  You should supply the two numbers as command line arguments.
	\TODO{additional exercise: write a second command and pipe the two together, maybe with a sort in the middle}
\end{exercise}

\section{Functions}
\TODO{make sure people are aware of tab/spaces and their significance in python}

\begin{itemize}
	\item We have already come across some functions provided by Python, such as \shellcmd{sqrt()} and \shellcmd{print()}.  We can also define our own functions in our Python programs.
	\item Functions in Python are somewhat more general that functions in mathematics because they do not need to take any input or return any output.
	\item The behaviour of a function has to be defined before it can be used in an expression.  We do this with the \shellcmd{def} keyword.  The behaviour of the function follows on subsequent indented lines.
	\item The most trivial function is one which has no input or output, and does nothing:
\begin{minted}{python}
def do_nothing():
	pass
\end{minted}
This function has the name \shellcmd{do\_nothing}.  It has just one line of code that defines its behaviour: we use the special \shellcmd{pass} keyword to instruct Python to do nothing.  We can call this function by writing \shellcmd{do\_nothing()}.
	\item A more interesting function takes one or more arguments.  For example, we can rewrite our circle area calculator as a function with two arguments:
\begin{minted}{python}
def print_circle_area(radius, area):
	print("The area of a circle " + \
	"with radius {r} is {area:.4g}" \
	.format(r=radius, area=area))

radius = 4.5
print_circle_area(radius, pi*radius**2)
\end{minted}
\item It is good practice to document functions using multi-line strings:
\begin{minted}{python}
def print_circle_area(radius, area):
	"""Print the specified radius and area of a circle.
	Radius is printed with Python default formatting.
	Area is formatted to four significant digits"""

	print("The area of a circle " + \
	"with radius {r} is {area:.4g}" \
	.format(r=radius, area=area))
\end{minted}

\item A function can also return a value.  Coming back to the circle area calculator, we can now rewrite the program as follows
\begin{minted}{python}
#!/usr/bin/env python3
from math import *

def circle_area(radius):
	return pi*radius**2

def print_circle_area(radius, area):
	print("The area of a circle " + \
	"with radius {r} is {area:.4g}" \
	.format(r=radius, area=area))

radius = 4.5
area = circle_area(radius)
print_circle_area(radius, area)
\end{minted}
\textit{Can you see a potential problem with the \texttt{print\_circle\_area()} function?  How might you improve it?}
\item \TODO{default arguments}
\end{itemize}

\section{Control structures}
\begin{itemize}
	\item We can evaluate boolean expressions to control which lines of code are executed.  For example
\begin{minted}{python}
bank_balance = -13

if bank_balance >= 0:
	print('In the black')
else:
	print('Overdrawn')
\end{minted}
Once again, we use indentation to specify the lines of code that belong to each case.
	\item If we need to test for more than one condition, we can use the \shellcmd{elif} keyword (a contraction of `else if')
\begin{minted}{python}
velocity = 23

if velocity < 0:
	print('Reverse gear')
elif velocity > 40:
	print('High gear')
elif velocity > 0:
	print('Low gear')
else:
	print('Neutral')
\end{minted}
Notice that we can use as multiple \shellcmd{elif} statements.
	\item If we need to execute the same code many times, we can use a control structure called a `loop'.  Python offers two loop types: the \shellcmd{while} loop and the \shellcmd{for} loop.  We discuss \shellcmd{for} loops later in section \TODO{xref}.
	\item A \shellcmd{while} loop is used to repeatedly execute code until a given boolean expression evaluates to \shellcmd{True}:
\begin{minted}{python}
counter = 5
while counter > 0:
	print(counter)
	counter -= 1

print('Blast off!')
\end{minted}
We will rewrite this more succinctly using a \shellcmd{for} loop in Practical \TODO{xref}.
\end{itemize}

\section{Python arrays}
An array is a data structure that holds an ordered list of values.  We will look at two array implementations: first, Python's built-in array data type and, second, the array type provided by the \shellcmd{numpy} module.  In this section, we will look at Python's built-in arrays.

\subsection{Creation}
\begin{itemize}
\item We can create an array by surrounding a comma-separated list with square brackets.  Example arrays are \shellcmd{[5.8, 2.0, -4.3e2]}, \shellcmd{["bob", "charlie", "alice"]}, and \shellcmd{[]} (an array with no elements)
\item It is good practice to use the same data type for all array elements (for example, an array of integers, or an array of booleans, but not an array containing a mixture of integer and boolean elements)
\item To create an integer sequence, use the \shellcmd{range()} function.  This function lets you specify the end of the sequence, the start and end, and an optional step.  Here are some examples:
\begin{minted}{python}
	range(3)         # [0, 1, 2]
	range(2, 5)      # [2, 3, 4]
	range(3, -7, -3) # [3, 0, -3, -6]
\end{minted}
\end{itemize}

\subsection{Querying}
\begin{itemize}
\item To determine the number of elements in an array, use the \shellcmd{len()} function.  For example, \shellcmd{len([6, 2, 8])} evaluates to 3, and \shellcmd{len([])} evaluates to 0.
\end{itemize}

\subsection{Modification}
% nesting
% range()
% indexing
% slicing

\begin{exercise}
\TODO{rewrite the Blast off! example using a for loop}
\end{exercise}

%\url{https://docs.python.org/3/tutorial/floatingpoint.html}

\end{document}
